#  数据结构与算法

[TOC]

## 第一章

### 一、数据结构定义

1. #### 计算机解决问题的过程

   1. **建立模型**
   2. **构造求解算法**
   3. **选择存储结构**
   4. **编写程序**
   5. **测试**

2. #### 算法

   1. 五类基本算法
      1. **贪婪算法**
      2. **分而治之法**
      3. **动态规划**
      4. **回溯法**
      5. **分支定界**
   2. 其他高级算法
      1. 线性规划
      2. 整数规划
      3. 遗传算法
      4. 模拟退火等
   3. 非数值基础算法
      1. 穷举法
      2. 贪心法（Huffman树，以最小代价生成树的Prim算法和Kruskal算法
      3. 分治法（递归法）
      4. 回溯法（深度优先、八皇后）
      5. 分支定界法（广度优先）
      6. 动态规划法（最佳二叉排序树）
      7. å-ß裁剪和分支界限法
      8. 并行算法

3. #### 数据结构研究对象

   1. 逻辑结构
      1. 反映数据元素间的逻辑关系
         1. **线性结构**
         2. **树结构**
         3. **图结构**
   2. 存储结构
      1. 反映数据元素及其关系在计算机存储器内的存储安排
         1. **顺序存储**
         2. **链式存储**
         3. **索引存储**
         4. **散列存储**
   3. 运算对数据的最主要操作
      1. **增**
      2. **删**
      3. **改**
      4. **查**

4. #### 不同数据结构操作集不同，但以下不可或缺

   1. 结构的生成
   2. 结构的销毁
   3. 在结构中查找满足规定条件的数据元素
   4. 在结构中插入新的数据元素
   5. 删除结构中已经存在的数据元素
   6. 遍历

5. #### 什么是数据结构

   1. 在计算机组织存储传递数据需讨论类和数据间的关系，以建立相应的数据结构，实现软件功能
   2. 数据结构描述现实世界实体的数据模型及其上的操作在计算机中的表示和实现
   3. 简单地说，**数据结构是一门研究数值计算的程序设计问题中计算机操作对象及它们之间关系和操作等等的学科**
      1. 数据结构是以某种特定的布局方式存储数据的容器
      2. 数据是计算机科学中最关键的载体而数据结构则可以将数据以某种形式存储
      3. 数据需要根据不同场景，按照特定的格式进行存储

### 二、基本概念和术语

1. 数据(Data)

   1. **被计算机识别和处理的符号集合**
   2. 包括
      1. 数值性数据
      2. 非数值性数据

2. 数据元素(data element)

   1. **数据基本单位**。
   2. 一个数据元素由若干的数据项(data Item)组成
   3. 数据元素又称元素、结点、记录
   4. 例如：一个学生记录、树中期盼的一个格局（状态）、图中的一个顶点等

3. 数据项(data item)

   1. **是组成数据元素的**、**有独立含义的**、**不可分割的最小单位**
   2. 如：学生基本信息中的学号、姓名、性别等
   3. 数据项是具有独立含义的最小标识单位

4. 数据对象(data object)

   1. **具有相同性质的数据元素集合**
      1. 举例
         1. 整数数据对象
            1. N={0,+-1,+-2,...}
         2. 字母字符数据对象
            1. C={'A','B',....'Z'}

5. 数据对象

   1. 数据元素1
      1. 数据项1
   2. 数据元素2
      1. 数据项1
      2. 数据项2
   3. 数据元素3
      1. 数据项1
      2. 数据项2
      3. 数据项3

6. 数据结构(data structure)

   1. 形式定义：**数据结构是相互之间存在一种或者多种特定关系的数据元素的集合**
   2. 用二元组记为
      1. Data_Structure = {D,S}
   3. 其中D为某一数据对象，S是该对象中所有数据乘员之间关系的有限集合
   4. 结构
      1. 元素之间的关系称结构
         1. 关系：描述的是数据元素之间的逻辑关系，称为数据的逻辑结构

7. 数据的逻辑结构

   1. 从逻辑关系上描述数据，与数据存储无关
   2. 从具体问题抽象出来的数据模型
   3. 与数据元素本身的形式、内容无关
   4. 与数据元素的相对位置无关
   5. 数据的逻辑结构分类
      1. 线性结构
         1. 线性表
      2. 非线性结构
         1. 树
         2. 图（或网络）

8. 数据的存储结构（物理结构）

   1. 数据结构在计算机中的表示
   2. 数据的存储结构依赖于计算机语言
      1. 顺序存储
      2. 链式存储
      3. 索引存储
      4. 散列存储

9. 注意：

   1. 数据的逻辑结构与存储结构密切相关

      1. **算法的设计取决于数据的逻辑结构**

      2. **算法的实现取决于数据的物理结构**

         >逻辑结构是数据元素之间的关系，存储结构是数据元素及其关系在计算机中的存储方式

### 三、抽象数据类型

- 数据类型

  - 定义：一个值的集合和定义在这个值集上的一组操作的总称
  - C中基本的数据类型
    - int char float double void

- 抽象数据类型

  - 是指一个数学模型及定义在此数学模型上的一组操作

  - 数据结构+定义在此数据结构上的一组操作=抽象数据类型

    - 如:矩阵+（求转置、加、乘、求逆、求特征值）

      构成一个矩阵的抽象数据类型

- 数据类型就是数据结构

- 数据类型是模版

- 基本数据类型可以看作是计算机中已实现的数据结构

- 构造数据类型由基本数据类型或构造数据类型组成

- 构造数据类型由不同分类型组成

1. 抽象数据类型的形式定义

   1. 抽象数据类型用三元组表示(D,S,P)

      1. D数据对象
      2. S是D上的关系集
      3. P是对D的基本操作集

   2. ADT抽象数据类型名 {

      ​	数据对象:<数据对象的定义\>

      ​	数据关系:<数据关系的定义>

      ​	基本操作:<基本操作的定义\>

      }ADT抽象数据类型名

2. ADT是指一个数据模型以及定义在该模型上的一组操作

   1. ADT
      1. 数据逻辑结构
      2. 抽象运算
   2. 对求解一个问题的形式化描述，面向用户，目的是使问题描述和问题实现相分离

3. 作用：有了ADT 程序员就可以将数据逻辑结构映射为存储结构，再在存储结构上设计抽象运算对应的算法，从而实现该ADT，一个数据类型可以看作是已经实现了抽象的数据类型。

>**思考：数据类型与数据结构的区别和联系是什么？**
>
>答:数据结构是相互之间存在一种成多种特定关系的数据元素的集合，一般包括数据逻辑结构、存储结构和数据的运算3方面的内容。
>
>而数据类型是一个值的集合和定义在这个值集上的一组运算的总称，例如，C语言** **short int****数据类型(短整型)的值集合为-32768～32767，一组运算是+、-、\*、/,%等.
>
>可以将一种数据类型看成是一种实现了的数据结构。**

### 小结

- **数据结构的三个方面：**

1. 数据的逻辑结构
   1. 线性结构
      1. 线性表
      2. 栈
      3. 队
   2. 非线性结构
      1. 树
      2. 图
2. 数据的存储结构
   1. 顺序存储
   2. 链式存储
3. 数据的操作
   1. 增
   2. 删
   3. 改
   4. 查

- **数据结构****是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
- 换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。
- 或者说数据结构就是数据元素的组织形式。**

### 作业一

**1. 简述下列概念：数据、数据元素、数据项**

**数据对象、数据结构、逻辑结构、存储结构**

**抽象数据类型。**

**2. 写一个函数find，实现从数组a[n]查找元素x，返回x在数组中的序号，如果找不到则返回-1。**

**3. 当a[n]递增有序时，有没有高效的算法？**

1.

（1）数据：指的是在计算机科学中所有能输入到计算机中并被计算机程序处理的符号到总称。

（2）数据元素：是数据的基本单位。

（3）数据项：若干数据项可组成一个数据元素。

（4）数据对象：性质相同的数据元素的集合。

（5）数据结构：是相互之间存在一种或者多种特定关系的数据元素的集合。

（6）逻辑结构：数据元素之间的相互关系，可分为集合，线性结构，树形结构，图状结构。

（7）存储结构：包括数据元素的表示和关系的表示。分为顺序存储结构和链式存储结构。

（8）抽象数据类型：ADT=数据对象+数据关系+基本操作。

2.数组无序，采取遍历数组形式查找；

```c++
int find(int a[],int n,int x){
    int i=0;
    while(i<n){
        if (a[i]==x){
            return i;
        }
        else{
            i++;}
    }
    return -1;
}

int main(){
    int a[8]={1,3,2,5,6,4,7,8};
    int n = sizeof(a);
    int x;
    printf("请输入你想查找的整数\n");
    scanf("%d", &x);
    int k = find(a,n,x);
    if (k!=-1){
        printf("找到了，在索引%d位置",k);
    }
    else {
        printf("没找到");
    }
    return 0;
}

```

3.当有序时，可以采用二分查找法：

```c
int find(int a[], int n, int x)
{

    int low = 0;
    int high = n - 1;
    while (low <= high)
    {
        int mid = (low + high) / 2;
        int middle = a[mid];
        if (middle < x)
        {
            low = mid + 1;
        }
        else if (middle > x)
        {
            high = mid - 1;
        }
        else
        {
            return mid;
        }
    }
    return 0;
}
int main()
{
    int a[8] = {1, 2, 3, 4, 5, 6, 7, 8};
    int n = sizeof(a);
    int x;
    printf("\n请输人所要查找的元素：");
    scanf("%d", &x);
    int result = find(a, n, x);
    if (result)
    {
        printf("找到了,在位置%d\n", result);
    }
    else
    {
        printf("没找到\n");
    }
    return 0;
}
```

### 四、算法分析

- 算法：

  - 是对特定问题求解步骤的一种描述,是一个有穷的指令集，这些指令表示一个或多个操作
  - 特性；
    - 有穷性
    - 确定性
    - 可行性
    - 输入
    - 输出

- 好算法的标准

  - 正确性
  - 可读性
  - 健壮性
  - 高效率与低存储

- 算法的事前估计

  - 时间复杂度
  - 运行时间=算法中每条语句执行时间之和
  - 每条语句执行时间=该语句的执行次数*该语句执行一次所需要的时间

- 常见算法时间复杂度

  - O(1) : 表示算法的运行时间为常量
  -  O(n) : 表示该算法是线性算法
  -  O(logn): 二分查找算法
  -  O(n2) : 对数组进行排序的各种简单算法，例如直接插入排序的算法。
  -  O(n3) : 做两个n阶矩阵的乘法运算
  -  O(2n) : 求具有n个元素集合的所有子集的算法
  -  O(n!) : 求具有N个元素的全排列的算法

- **O(1)<O(㏒n)<O(n)<O(****n㏒n)< O(n2)<)< O(n3) < O(2n) < O(n!) < O(nn)**

- 空间复杂度

  - 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量，记作：

  -    S(n) = O(g(n))

  - 表示随着问题规模n的增大，算法运行所需存储量的增长率与g(n)的增长率相同。

  - 算法的存储量包括：

    1．输入数据所占空间; 

    2．程序本身所占空间； 

    3．辅助变量所占空间。 

- 存储空间的两个部分

  - **存储空间的固定部分****

    - 程序指令代码的空间，常数、简单变量、定长成分(如数组元素、结构成分、对象的数据成员等)变量所占空间

  - 可变部分

    -  尺寸与实例特性有关的成分变量所占空间、引用变量所占空间、递归栈所用空间、通过new和delete命令动态使用空间**

  - **注意：一个算法的临时存储空间是指函数内新开辟的空间，不包括形参占用的空间**

  - ```C
    int fun (int a[], int n){ int i,s=0;
    for(i=0; i=n; i++) 
        s+=a[i];
    return s; 
    
    ```

  - **函数体内只开辟了****i，s变量空间，与n无关，所以空间复杂度为O(1)。不计形参a占用的空间。**

    

### 作业二

- **1.**   **以Niklus Wirth的观点，程序是什么?** 

  - **程序=数据结构+算法**

- **2.**   **算法有什么特性？**

  - **有穷性，确定性，可行性，输入，输出**

- **3.**   **好算法应满足哪些标准？**

  - **正确性，可读性，健壮性，高效率和低存储的需求**

- **4.**   **数据结构主要在哪些层面上讨论问题？**

  - **主要在逻辑结构，存储结构和运算这三个层面上讨论问题**

- **5. 分析下列算法的时间复杂度**

- ```c
   for(i=0;i<n;i++)
  
    for(j=0;j<m;j++)
  
     a[i][j]=0;
  
  
  ```

  - **频度为m\*n ---n^2**
  - T(n)=O(n^2)

- ```c
   s=0;
   for(i＝0; i＜n;i++)
  
    for(j＝0;j<n;j++)
  
  s+＝B[i][j]
   sum=s;
  ```

  - **频度为 2+n^2**
  - **T(n)=O(n^2)**

- **(3)**

- ```
  i=1；
   while(i<=n)
   i=i\*3;
  
  ```

  - **3^k=n 所以 k=log3 n**
  - **T(n)=O(log3 n)**

- ```c
   x=0;
   for(i＝1;i＜n;i++)
  
    for(j＝1;j<＝n-1;j++)
      x++;
  
  sum=s;
  
  
  ```

  - **频度为 n\*(n-1)**
  - **T(n)=O(n^2)**



## 第二章 线性表

**1.** **了解线性结构的特点**

**2.********掌握顺序表的定义、查找、插入和删除**

**3.****掌握链表的定义、创建、查找、插入和删除**

**4.****能够从时间和空间复杂度的角度比较两种存储结构的不同特点及其适用场合**

1. 线性结构特点

   在数据元素的非空有限集合中，同一线性表中元素具有相同特性，相邻元素之间存在序偶关系

   1. 存在唯一一个被叫做第一个的数据元素
   2. 存在唯一一个被叫做最后一个的数据元素
   3. 除第一个元素外，每个数据元素均有唯一一个直接前驱
   4. 除最后一个元素外，每个元素都有唯一一个直接后继

2. 线性表

   1. 是一种典型的线性结构
   2. 数据的运算是定义在逻辑结构上的，而运算的具体实现则是在存储结构上进行的

3. 线性表的存储结构

   1. 顺序表

      把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里，用这种方法存储的线性表简称顺序表

      1. 逻辑上相邻，物理上也相邻
      2. 顺序存储方法:用一组地址连续的存储单元存储线性表的元素，可通过数组V[n]实现

   2. 顺序存储

      1. 定义：将线性表中元素相继存放在一个连续的存储空间中
      2. 存储结构：数组
      3. 特点：顺序存储
      4. 存取方式：随机存取

4. 顺序表的存储结构定义

### 静态分配的顺序表

1. 静态分配的顺序表存储

   1. ```c
      #define  ListSize  100           //最大允许长度
      typedef  struct { 
              ListData  data[ListSize] ;      //存储空间
              int  length;                      //当前元素个数
          } SeqList;
      ```

   2. 静态存储的基本操作

      1.InitList(&L)；初始化线性表L为空表；

      ```c
          void InitList ( SeqList  &L )
          {                           //初始化表L为空表
               L.length = 0;
           }
      ```

      2、DestroyList(&L)回收(销毁)线性表L

      ```c
      void DestroyList(SqList &L)//销毁线性表L 
      { 
        if (L.data){
      		delete L.data;//释放存储空间(删除此数组)
      	}
      }
      ```

      3、 ClearList(&L)  清空线性表L

      ```c
       void ClearList(SeqList &L)     //清空线性表L
        {
          L.length=0;
        }
      ```

       4、 **ListEmpty(SeqList **L) 判断线性表L是否为空，若为空返回1,否则返回0；

       

      ```c
      int ListEmpty(SeqList L) {//若线性表L为空返回1,否则返回****0**
            return(!(L.length)) ;
       }
      ```

       5、 ListLength ( L ) 求表L的长度 

      ```c
       int ListLength ( SeqList L )
        {                            //函数值是表L的长度
         return(L.length);
        }
      ```

       6、 GetElem ( L, i ) 函数值为线性表L中第 i个元素

      ```c
         ListData GetElem ( SeqList L, int i ) { //函数值为表L中第 i 个元素
      
       if (1<=i && i <= L.length )      
           return (L.data[i-1]); //第i-1的单元存储着第i个数据
       else return “Error”;
       }
      ```

       7-1、LocateElem( L, x ) 查找x在表L中的位置, 若查找成功，返回x的位置，否则返回-1

      ```c
        int LocateElem( SeqList L, ListData x ) {//查找x在表  
      
          //L中位置, 若查找成功，返回x的位置，否则返回-1
      
        int i = 0;
      
        while ((i<L.length)&&(L.data[i]!=x)) i++;  //查找
      
        if ( i<L.length ) return i;                  //成功
      
         else return -1;                           //失败
      
       }
      ```

      7-2、 IsIn ( L, x ) 判断x是否在表L中，是返回1否则返回0

      ```c
      int IsIn ( SeqList L, ListData x ) { //判断x是否在表L中
      
                     //x在L中返回1，否则返回0
      
      int i = 0, found=0;
      
      while ((i< L.length)&&!found )
      
        if(L.data[i]!= x ) i++;
      
           else found=1;
      
      return found;
      
      }
      ```

      8、 NextElem (L, x ) 求x的直接后继

      ```c
      int NextElem ( SeqList L, ListData x ) { //如果x在表L中且
      
         //有直接后继，函数值返回其直接后继的位置，否则返回-1
      
       int i=0;
      
       while ((i<L.length)&&(L.data[i]!=x)) i++;  //查找x
      
       if ((0<=i)&&(i<L.length-1)) return i+1;      
      
         else return -1;
      
       }
      ```

      9、 PriorElem (L, x )求x的直接前驱

      ```c
       int PriorElem ( SeqList L, ListData x ) {  //如果x在表L中且
      
         //有直接前驱，函数值返回其直接后继的位置，否则返回-1
      
       int i=0;
      
       while (i< L.length && L.data[i]!=x) i++;     //查找x
      
       if ((0< i)&&(i<L.length)) return i-1;   //返回位置
      
          else return -1;
      
       }
      ```

      10、ListInsert (&L, i, x ) 在顺序表L中第 i 个元素前插入 x,插入成功返回1，不成功 返回0 n/2

      ```c
       int ListInsert ( SeqList &L, int i , ListData x) { //在顺序表L中
      
            //第 i 个元素前插入 x,插入成功返回1，不成功 返回0
      
       if ((i < 1)||(i >L.length+1)||(L.length==ListSize))
         return 0;                            //插入不成功 
        else {for ( int j = L.length; j >i-1; j-- )           //后移
              L.data[j]=L.data[j-1]; 
            L.data[i-1]=x;  L.length++; return 1;   //插入成功    
           }
      }
      ```

      11、ListDelete (&L, i) 在顺序表L中删除第i个元素删除成功返回1，否则返回0 (n-1)/2

      ```c
       int ListDelete ( SeqList &L, int i) {//在顺序表L中删除第i个元素,
                                 //成功返回1，否则返回0
       if (i<1)||(i>L.length) return 0;
       L.length -- ; 
       for ( int j = i-1; j < L.length+1; j++ )    //前移
         L.data[j]=L.data[j+1];
       return 1;                      //成功删除 
       }
      ```

      算法时间复杂度分析

      ​	查找、插入、删除的平均时间复杂度为 O(n)

      空间复杂度为S(n) = O(1) 没有占用辅助空间

### 动态分配的顺序表

1. 动态分配的顺序表存储

   1. 动态分配顺序存储结构

      1. ```c
         #define LIST_INIT_SIZE 10    // 线性表存储空间的初始分配量
         #define LISTINCREMENT 5 // 线性表存储空间的分配增量
          typedef struct
          {
           ListData *data;     // 存储空间基址
           int length;     // 顺序表当前长度
           int listsize;// 当前分配的存储容量(以sizeof(ListData)为单位
          }SqList;
         ```

   2. 基本操作

      1、InitList(& L)；初始化线性表L为空表；

      ```c
      int InitList(SqList &L)
      {                 // 分配指定大小的存储空间给顺序表
       L.data = (ListData*)malloc(LIST_INIT_SIZE*sizeof(ListData));  //分配存储单元
       if( !L.data )                  // 存储分配失败
      		 exit(0);
      L.length = 0;               // 当前长度初始化为0
      L.listsize = LIST_INIT_SIZE; // 指定分配的存储容量 
       return 1;
      }
      ```

      2、DestroyList(&L) 回收顺序线性表L，将顺序表结构体中的所有成员销毁（空间释放， 数值置0）

      ```c
      int DestroyList(SqList &L)
      {           // 先释放空间，然后置空
       free( L.data );
       L.length = 0;
       L.listsize = 0;
       return 1;
      }
      ```

       3、 ClearList(&L)  清空线性表L

      ```c
       int ClearList(SqList &L)
      {          //清空线性表L
       L.length = 0;
       return 1;
      }
      ```

       4、 ListEmpty(SeqList L) 判断线性表L是否为空，若为 

      ​    空返回1,否则返回0；

      ```c
      int ListEmpty(SqList L)
      {  
         return(!(L.length))
      }
      ```

      5、 ListLength (L ) 求表L的长度 

      ```c
      int ListLength(SqList L)
      {
         // L.length记录当前顺序表的长度，直接返回
      return (L.length);
      }
      ```

       6、 GetElem ( L, i ) 函数值为表L中第 i个元素

      ```c
       ListData GetElem(SqList L, int i) {//函数值为表L中                               //第 i 个元素
        if (1<=i && i <= L.length )      
           return (*(L.data+i-1));
          else return NULL; 
        }     
      ```

      7-1、LocateElem(L, x ) 查找x在表L中的位置, 若查找成功，返回x的位置，否则返回-1

      ```c
       int LocateElem( SqList L, ListData x ) {//查找x在表  
           //L中位置, 若查找成功，返回x的位置，否则返回-1
        int i = 0;
        while ((i<L.length)&&(*(L.data+i)!=x)) i++;  //查找
        if ( i<L.length ) return i;                  //成功,返回位置
         else return -1;                          //失败
       }
      ```

      7-2、 IsIn ( L, x ) 判断x是否在表L中，是返回1否则返回0

      ```c
      int IsIn ( SqList L, ListData x ) { //判断x是否在表L中
                     //x在L中返回1，否则返回0
      int i = 0, found=0;
      while ((i< L.length)&&!found )
        if(*(L.data+i)!= x ) i++;
           else found=1;
      return found;
      }
      ```

      8、 NextElem (L, x ) 求x的直接后继

      ```c
      int NextElem ( SqList L, ListData x ) { //如果x在表L中且
         //有直接后继，函数值返回其直接后继的位置，否则返回-1
       int i=0;
       while ((i<L.length)&&(*(L.data+i)!=x)) i++;  //查找x
       if ((0<=i)&&(i<L.length-1)) return i+1;      
         else return -1;
       }
      ```

      9、 PriorElem (L, x )求x的直接前驱

      ```c
       int PriorElem ( SqList L, ListData x ) {  //如果x在表L中且
         //有直接前驱，函数值返回其直接后继的位置，否则返回-1
       int i=0;
       while (i< L.length && *(L.data+i)!=x) i++;     //查找x
       if ((0< i)&&(i<L.length)) return i-1;
          else return -1;
       }
      ```

      10、ListInsert (&L, i, e) 在顺序表L中第 i 个元素前插入e,成功返回1，否则返回0

      ```c
       int ListInsert(SqList &L, int i, ListData e)
      {ListData *newbase, *q, *p;
      if((i < 1) || (i > L.length + 1)) return 0;     //输入的i不合法
      if( L.length == L.listsize)              // 当前存储空间已满, 增加分配空间
       {      // realloc改变L.data所指内存的大小，原始所指内存中的数据不变。
        newbase = (ListData *)realloc(L.data, (L.listsize + LISTINCREMENT) * sizeof(ListData));
        if( !newbase ) exit(0);                               //申请新空间失败
         L.data = newbase;                              // 新基址
         L.listsize += LISTINCREMENT;                  // 增加存储容量
        }
       q = L.data + i - 1;                                  // 指定插入的位置
       for(p = L.data + L.length - 1; p >= q; --p) *(p+1) = *p;   // q之后的元素右移
       *q = e;  ++L.length; return 1;             // 插入e ，表长增1
      }
      ```

      11、ListDelete (&L, i) 在顺序表L中删除第i个元素，成功返回1，否则返回0

      ```c
      int ListDelete(SqList &L, int i)
      { ListData *p,*q;
        if( i < 1 || i > L.length) return 0;     // i值不合法
        p = L.data + i - 1;  // p为被删除元素的位置
        q = L.data + L.length-1;        // 表尾元素的位置
        for(++p; p <= q; ++p) // 被删除元素之后的元素左移
       *(p-1) = *p;
       L.length--; // 表长减1
        return 1;
      }
      ```

      顺序表的优缺点

      - 优点 
        - 存储密度大
        - 可以随机存取表中任一元素
      - 缺点
        - 在插入删除某一元素时，需要移动大量元素
        - 浪费存储空间
        - 属于静态存储形式，数据元素的个数不能自由扩充
        - 克服这一缺点-》链表

### 第二章作业一

已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为item的数据元素。

解：

（1）算法思路

时间复杂度为O(n)即for 或者 while出现的次数最多为一次，空间复杂度为O(1)即在删除item过程中不能重新开辟一个数组，分配的空间不随处理数据量变化。则能想到用一个临时变量存储单次遍历中与item值不相同的值，并在当前循环中把值覆盖到原本线性表中从j==0开始的data[j]中，并且每次赋值后j递增1，遍历后所得的j即为新的线性表长度，最后赋值给length即完成顺序表删除相同元素并且改变线性表长度的操作。

（2）算法实现

```c
#define ListSize 10//最大允许长度
//静态分配的顺序表存储
typedef int ListData;
typedef struct {
  ListData data[ListSize]; //存储个数
  int length;//当前元素个数
}SqList;
//删除线性表中item值元素
int DeleteItem(SqList &L,int item){
  int temp; //储存临时变量
  int j=0;
  for(int i=0;i<L.length;i++){ //遍历顺序表
    if(L.data[i]!=item){
      temp=L.data[i]; //不等于item的线性表元素值存储到临时变量中
      L.data[j]=temp; //替换掉索引为j的线性表元素
      j++; //每替换一次 j的值加一
    }
  }
  L.length=j; //线性表长度缩小为j
  return 1;
}
int main(int argc, const char * argv[]) {
  SqList SL;
  InitList(SL);
  SL.length=10;
  int j=0;
  for(int i=0;i<10;i++){ //给线性表赋值，偶数索引对应值为2 单数索引对应值为1+i
    if(i%2==0){
      j=2;
    }else j=1+i;
    SL.data[i]=j;}
  for(int i=0;i<SL.length;i++){
    printf("SL[%d]=%d\n",i,SL.data[i]); //打印顺序表中的值
  }
  DeleteItem(SL, 2); //删除item==2的顺序表元素
  for(int i=0;i<SL.length;i++){
    printf("SL[%d]=%d\n",i,SL.data[i]); //打印删除相同item后的顺序表
  }
  return 0;
}
```

### 线性表的链式存储结构 链表(Linked List)

- 单链表
- 静态链表
- 循环链表
- 双向链表

链式存储有关术语

1. 结点：数据元素的存储映像，由数据域和指针域组成

2. 链表：n个结点由指针链组成一个链表，它是线性表存储映像，称为线性表的链式存储结构

3. 单链表、双链表、循环链表：

   1. 结点只有一个指针域，称为单链表或线性链表
   2. 有两个指针域的链表，称为双链表
   3. 首尾相接的链表称为循环链表

4. 头指针、头结点和首元节点:

   1. 头指针是指向链表中第一个结点的指针
   2. 首元结点是指链表中存储第一个数据元素a1的结点
   3. 头结点是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息

5. 在链表中设置头节点有什么好处

   1. 便于首元结点处理
   2. 便于空表和非空表的统一处理

6. 头结点的数据域内装的是什么

   1. 头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不可以计入链表长度值

7. 链式（链式存储结构）的特点

   1. 结点在存储器的位置不是任意的，即逻辑上相邻的数据元素在物理上的不一定相邻
   2. 访问时只能通过头指针进入链表，并通过每个结点的结点的指针域后扫描其余结点，所以寻找第一个结点和最后一个结点所话费的时间不等
   3. 顺序存储

   链表的优缺点

   - 优点
     - 数据元素的个数可以自由扩充
     - 插入、删除等操作不必移动元素，只需修改链接指针，修改效率较高
   - 缺点
     - 存储密度小
     - 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问

### 单链表

单链表结构定义

```c
typedef char ListData;
typedef struct node {              //链表结点 
   ListData  data;            //结点数据域
   struct node * next;            //结点链域
 } ListNode;
typedef ListNode * LinkList;      //链表头指针
```

1.InitList(&first)；初始化单链表first为空表；

```c
 void InitList(LinkList  &first){  //初始化单链表first为空表
     first=NULL;
   }
```

2、DestroyList(&first) 销毁单链表first

```c
void DestroyList(LinkList &first) {
                      //删去单链表first的所有结点
  ListNode *q;
  while (first ) {
              //当链不空时，循环逐个删去所有结点
     q =first；first= first→next;
    free( q );    //释放 
  } 
}
```

 3、 ClearList(&first)  清空单链表first

```c
void clear ( LinkList  &first ) {
                      //删去单链表first中所有结点
  ListNode *q;
  while (first ) {
              //当链不空时，循环逐个删去所有结点
     q =first; first = first→next;
    free( q );    //释放 
   } 
 }
```

 4、 ListEmpty(first) 判断单链表first是否为空，若为空返回1, 否则返回0；

```c
 int ListEmpty(LinkList first)
  {            //若单链表first为空返回1,否则返回0
     return !first ;  
  }
```

5、 ListLength ( first ) 求单链表first的长度 

```c
int ListLength(LinkList first)  //函数值为单链表first长度
  {
    LinkList p;
    p=first;
    int count=0;
    while(p)
    {
      p=p→next;     count++;  
    }
    return count;  
  }
```

 6、 GetElem ( first, i ) 函数值为单链表first中第 i个元素

```c
  ListData GetElem(LinkList first, int i)
  {  //函数返回单链表first中第i个元素值，不存在返回NULL
    LinkList p;    int j;
    p=first; j=1;
    while (p&&(j<i)) {               //找第i个元素
      p=p→next; ++j;
    }
    if (!p||j>i) return NULL;  //第i个元素不存在,p 空没找到
                          //j>i 是输入i<1的情况
    return p→data;
  }
```

 7-1、LocateElem( first, x ) 查找x在单链表first中位置, 若查找成功，返回x的位置，否则返回NULL

```c
LinkList LocateElem( LinkList first, ListData x ) {//在单链表first中
    //搜索数据值为x的结点，成功返回x第一次出现的位置，否则返回NULL
   ListNode * p = first;        //指针 p 指示第一个结点
   while ( p && (p→data != x)) 
     p = p→next;
   return p;   
}
```

7-2、 IsIn ( first, x ) 若x在单链表first中函数返回1否则返回0

```c
  int IsIn (( LinkList first, ListData x )
  {               //若x在单链表first中函数返回1否则返回0
  ListNode * p = first;            //指针 p 指示第一个结点
  while ( p && (p→data != x))    //找x
    p = p→next;
  return !(p==NULL);   
} 
```

8、 NextElem (first, x ) 求x的直接后继

```c
LinkList NextElem(LinkList first, ListData x) { 
  //函数返回单链表//first中值为x结点的直接后继结点地址，没有返回NULL
 LinkList p=first;
 while(p&&p→data!=x)              //找x
     p=p→next;
 if (!p || ! p→next) return NULL;      //没有直接后继
 return p→next;          
 }
```

9、 PriorElem (first, x )求x的直接前驱

```c
LinkList PriorElem(LinkList first, ListData x) 
{     //函数返回x的直接前驱的结点地址，没有返回NULL
 LinkList p=first;
 while(p&&p→next &&(p→next→data!=x))        //找x
     p=p→next;
 if (!p ||! p→next) return NULL;         //没有直接前驱
 return p;          
 }
```

10、 ListInsert (&first, i, x )在单链表first第 i 个元素结点前插入元素 x

```c
int ListInsert ( LinkList &first, int i, ListData x) {
    //在单链表first中第 i 个元素结点前插入元素 x，成功返回1否则返回0
 newnode=(ListNode *) malloc ( sizeof (ListNode) );
 newnode→data = x;                 //创建新结点
 if (i==1) {                   //插入为第一个结点
     newnode→next = first;         //新结点成为第一个结点
     first = newnode;
     return 1; 
   } 
 p = first;  k = 1; {     //插入位置不是第一个结点
 while ( p && k < i-1) 
   { p = p→next; k++; }  //移动指针，找第 i-1个结点
 if ( !p || i<1) ) { 
   printf ( “无效的插入位置!\n” );        //终止插入
     free(newnode);
   return 0;
   }
 newnode→next = p→next;       
 p→next = newnode;              //插在表中间或末尾
 return 1; 
}
```

11、ListDelete (&first, i )在单链表first中删除第 i 个结点，

```c
int ListDelete ( LinkList &first, int i ) { 
        //在单链表first中删除第 i 个结点，删除成功返回1否则返回0
  if ( first&&i == 1 )             //删除表中第 1 个结点
    { q = first; first = first→next; }
  else {
    p = first;  k = 1;   
    while ( p && k < i-1 )
      { p = p→next; k++; }           //找第 i-1个结点
          if ( !p  || !(p→next) || i<1 ) {                                                                                            //找不到第i-1个结点
            printf ( “无效的删除位置!\n” );
            return 0;
         }
        else {q = p→next;                     //删除中间结点或尾结点元素         
                 p→next = q→next;        
                }
    }
  free ( q ); return 1;                                      //释放q
}
```

带头节点的单链表基本操作

1、InitList(&first)；

```c
初始化带头结点单链表first；
 void InitList(LinkList &first){ 
                   //初始化带头结点的单链表first为空表
  first = (ListNode *) malloc (sizeof (ListNode) );  //创建头结点 
  first→next=NULL;
  }
```

2、DestroyList(&first) 销毁带头节点单链表first

```c
void DestroyList(LinkList &first) {
 //删去带头节点单链表first中的所有结点，包括头结点
  ListNode *q;
  while (first ) {
              //当链不空时，循环逐个删去所有结点
     q =first；first= first→next;
    free( q );    //释放 
  } 
}
```

 3、 ClearList(&first)  清空带头结点单链表first

```c
 void clear ( LinkList  &first ) {   // 将表重置为空表
           //删去带头结点单链表first中的所有结点，保留头结点
  ListNode *p, *q=first→next;
  while (q ) {          //当链不空时，循环逐个删去所有结点
     p=q; q=q→next;
    free( p );          //释放 
   } ;
  first→next=NULL;   //头结点指针域为空
 }
```

 4、 ListEmpty(LinkList first) 判断带头结点单链表first是否为空，若为空返回1,否则返回0；

```c
 int ListEmpty(LinkList first)
  {            //若带头结点单链表first为空返回1,否则返回0
     return !(first→next) ;  
  }
```

5、 ListLength ( first ) 求带头结点单链表first的长度 

```c
int ListLength(LinkList first) //函数返回带头结点单链表first长度
  {
    LinkList p,q;
    p=first→next;
    int count=0;
    while(p)
    {
      p=p→next;     count++;  
    } 
    return count;  
  }
```

 6、 GetElem ( first, i ) 函数值为带头结点单链表first中第 i个元素

```c
 ListData GetElem(LinkList first,int i) {
          //函数返回带头结点单链表first第i个元素值，不存在返回NULL
    LinkList p;    int j;
    p=first→next; j=1;
    while (p&&(j<i)) {               //找第i个元素
      p=p→next; ++j;
    }
    if (!p||j>i) return NULL;              //第i个元素不存在
    return p→data;
  }
```

 7-1、LocateElem( first, x ) 查找x在带头结点单链表first中的位置, 若查找成功，返回x的位置，否则返回NULL

```c
ListNode * LocateElem( LinkList first, ListData x ) { //在带头结点单//链表first中搜索其值为x的结点，查找成功返回x位置，否则返回NULL
   ListNode * p = first→next;        //指针 p 指示第一个结点
   while ( p && (p→data != x)) 
     p = p→next;
   return p;   
}
```

7-2、 IsIn ( first, x ) 若x在带头结点单链表first中函数返回1否则返回0

```c
  int IsIn ( LinkList first, ListData x )
  {         //若x在带头结点单链表first中函数返回1否则返回0
  ListNode * p = first→next;            //指针 p 指示第一个结点
  while ( p && (p→data != x)) 
    p = p→next;
  return !(p==NULL);   
}
```

8、 NextElem (first, x ) 在带头结点单链表first中求x的直接后继

```c
LinkList NextElem(LinkList first, ListData x) { //函数返回带头结点单链表first中x的直接后继的结点地址，没有返回NULL
 LinkList p=first→next;
 while(p&&p→data!=x)              //找x
     p=p→next;
 if (!p || ! p→next) return NULL;      //没有直接后继
 return p→next;          
 }
```

9、 PriorElem (first, x )在带头结点单链表first中求x的直接前驱

```c
LinkList PriorElem(LinkList first, ListData x) { //函数返回带头结点单链表first中x的直接前驱的结点地址，没有返回NULL
LinkList p=first→next;
 while(p&&p→next &&(p→next→data!=x))           //找x
     p=p→next;
 if (!p||!p→next) return NULL;              //没有直接前驱 
 return p;         
 }
```

10、 ListInsert (first, i, x) 在带头节点单链表first第 i 个元素结点前插入元素 x

```c
int ListInsert (LinkList first, ListData x, int i ) {
           //在带头节点的单链表first中第 i 个元素结点前插入元素 x，成功返回1否则返回0
  p = first;  k = 0;
  while ( p && k < i -1 ) 
    { p = p→next; k++; }                        //寻找第 i-1个结点
  if ( !p || i<1) ) { 
    printf ( “无效的插入位置!\n” );                  //终止插入
    return 0;
  }                                        //参数i值不合理返回0
  newnode = (ListNode *) malloc (sizeof (ListNode) );    //创建新结点
  newnode→data = x; 
  newnode→next = p→next;                  //插入新结点
  p→next = newnode;
  return 1;   
}
```

11、 ListDelete (first, i ) 删除带头节点单链表first的第 i 个元素

```c
int ListDelete ( LinkList first, int i ) {
         //删除带头节点单链表first的第 i 个元素，成功返回1否则返回0
 p=first; k=0;
  while (p && k++<i-1) p= p→next;  //寻找第i-1个结点
  if ( !p ||!( p→next )|| i<1) 
   return 0;                     //i值不合理或空表 
   q = p→next;  
 p→next = q→next;               //删除结点
  free ( q );                    //释放
  return 1;
}
```

```c
LinkList createListF ( void ) {//创建带头结点单链表，函数返回
                                    //单链表的头指针
  head =                    //建立表头结点
    (LinkList) malloc (sizeof (ListNode));
  head→next = NULL;
  while ( (ch = getchar( ) ) != ‘\n’ ) {
     q = (listNode *) malloc (sizeof(ListNode));
     q→data = ch;                      //建立新结点
    q→next = head→next;             //插入到表前端
     head→next = q;
  }
  return head;
}  
```

```c
LinkList createListR ( void ) {{//创建带头结点单链表，函数返回
                                    //单链表的头指针
  head =(LinkList) malloc (sizeof (ListNode));
  r = head;                //建立表头结点，r 指向表尾
 while ( (ch = getchar( ) ) != ‘\n’ ) {
    q = (listNode *) malloc (sizeof(ListNode));
     q→data = ch;                        //建立新结点
     r →next = q;  r =q;                  //插入到表末端
  }
  r →next = NULL;    return head;
}  
```

### 静态链表

```c
const int MaxSize = 100;         //静态链表大小
typedef struct node {            //静态链表结点
  ListData data; // 数据域  
  int link; // 游标域 书上是“cur”
} SNode;
typedef struct {                 //静态链表
  SNode Nodes[MaxSize];
  int newptr;                  //当前可分配空间首地址
} SLinkList;
```

1、InitList(&Slink)；初始化带头结点静态链表Slink；

```c
 void InitList(SLinkList &Space，int &Slink){ 
                  //初始化带头结点的静态链表Slink为空表
 if (Space.newptr!=-1)  
 {Slink =Space.newptr;                  //创建头结点 
  Space.newptr= Space.Nodes[Space.newptr].link；}
                                   //删除备用链表第一结点
  Space.Nodes[Slink].link=-1;

  }
```

2、DestroyList(&Slink) 销毁带头节点静态链表Slink

```c
void DestroyList(SLinkList &Space，int &Slink) {
 //删去带头节点静态链表Slink所有结点，包括头结点
 q =Slink；                  //只需将销毁链插入到备用链表
 while (Space.Nodes[Slink].link!=-1)      //找链尾
 Slink=Space.Nodes[Slink].link;
 Space.Nodes[Slink].link=Space.newptr;//链接链尾与备用链表表头
 Space.newptr=q；        //设置备用链表头指针为销毁链头指针
 Slink=-1；
 }
```

 3、 ClearList(Slink) 清空带头节点静态链表Slink

```c
void DestroyList(SLinkList &Space，int Slink) {
    //清空带头节点静态链表Slink，保留头结点
 p = Space.Nodes[Slink].link；//将清空链插入到备用链表
 while (Space.Nodes[p].link!=-1)         //找链尾
   p=Space.Nodes[p].link;
 Space.Nodes[p].link=Space.newptr；
                    //把链尾和备用链表表头相连
 Space.newptr= Space.Nodes[Slink].link；         
                           //设置备用链表头指针
 Space.Nodes[Slink].link=-1;    //设置空链表尾指针
}
```

 4、 ListEmpty(Slink) 判断带头结点静态链表Slink是否为空，若为空返回1,否则返回0； 

```c
 int ListEmpty(SLinkList &Space，int Slink) 
 {          //若带头结点静态链表Slink为空返回1,否则返回0
     return (Space.Nodes[Slink].link==-1) ;  
 }
```

5、 ListLength (Slink) 求带头结点静态链表Slink的长度 

```c
int ListLength(SLinkList &Space，int Slink) {
             //函数返回带头结点静态链表Slink长度
int count=0; 
q=Slink；
while (Space.Nodes[q].link!=-1)      //在链上移动，计数
  {q=Space.Nodes[q].link; count++; }
return count;  
}
```

 6、 GetElem (Slink, i ) 函数值为带头结点静态链表Slink中第 i个元素

```c
 ListData GetElem(SLinkList &Space, int Slink, int i) {
     //函数返回带头结点静态链表Slink第i个元素值，不存在返回NULL
 int j=0; q=Slink；
 while (q!=-1&& j<i)      //找第i个元素
  {q=Space.Nodes[q].link; j++; }
 if (p=-1||j>i) return NULL;              //第i个元素不存在
 return Space.Nodes[q].data;
 }
```

7-1、LocateElem(SLink, x )  查找x在带头结点静态链表SLink中位置

```c
int LocateElem(SLinkList &Space, int Slink, ListData x )
{ //在带头结点静态链表Slink中找值为x结点，找到返回x位置，否则返回-1
 q=Space.Nodes[Slink].link；
 while (q!=-1&& Space.Nodes[q].data!=x)      //找X
   q=Space.Nodes[q].link;
 return q;
}
```

7-2、 IsIn(SLink, x ) 若x在带头结点静态链表Slink函数返回1否则返回0

```c
int IsIn(SLinkList &Space, int Slink, ListData x )
{ //在带头结点静态链表Slink中找值为x结点，找到返回1否则返回0
 q=Space.Nodes[Slink].link；
 while (q!=-1&& Space.Nodes[q].data!=x)      //找X
   q=Space.Nodes[q].link;
 return !(q=-1);
}
```

8、 NextElem (Slink, x ) 在带头结点静态链表Slink中求x的直接后继

```c
LinkList NextElem(SLinkList &Space, int Slink, ListData x )
{ ////函数返回带头结点静态链表Slink中x的直接后继地址，没有返回-1
 q=Space.Nodes[Slink].link；
 while (q!=-1&& Space.Nodes[q].data!=x)      //找X
   q=Space.Nodes[q].link;
} 
if (q=-1 || Space.Nodes[q].link=-1) return -1; //没有直接后继
return Space.Nodes[q].link;          
}
```

9、PriorElem (Slink, x ) 在带头结点静态链表Slink中求x的直接前驱

```c
LinkList NextElem(SLinkList &Space, int Slink, ListData x )
{ ////函数返回带头结点静态链表Slink中x的直接前驱地址，没有返回-1
 q=Space.Nodes[Slink].link；
 while (q!=-1&&Space.Nodes[q].link!=-1 &&Space.Nodes[Space.Nodes[q].link].data!=x)    //找X
   q=Space.Nodes[q].link;
 } 
if (q=-1 || Space.Nodes[q].link=-1) return -1;   //没有直接前驱
return q;          
}
```

10、 ListInsert (Slink, i, x)  在带头节点静态链表Slink的第 i 个元素结点前插入 x

```c
int ListInsert( SLinkList &Space, int Slink, int i, ListData x ) {
          //在带头节点的静态链表Slink第 i 个结点前插入x，插入成功返回1否则返回0
 int j=0; q=Slink；
 while (q!=-1&& j<i-1)            //找第i-1个元素
   {q=Space.Nodes[q].link; j++; }
 if (q==-1|| i<1 ) return 0;                            //插入位置 i 错误
 if (Space.newptr!=-1) {p=Space.newptr;                    //分配结点
                     Space.newptr = Space.Nodes[Space.newptr].link;}
   else return 0                             //备用链表空
 Space.Nodes[p].data = x;
 Space.Nodes[p].link = Space.Nodes[q].link;
 Space.Nodes[q].link = p;                       //插入
 return 1;
}
```

11、 ListDelete (Slink, i ) 删除带头节点静态链表Slink的第 i 个元素

```c
int ListDelete( SLinkList &Space, int Slink, int i ) {
  //在带头结点的静态链表Slink删除第 i 个元素结点，删除成功返回1否则返回0
 int p =Slink;
 int j=0;
 while (p!=-1&&j++<i-1) p=Space.Nodes[p].link;
 if ( p ==-1||Space.Nodes[p].link==-1 ||i<1) return 0; //找不到结点
 int q = Space.Nodes[p].link;           //准备删除第 i个元素结点
 Space.Nodes[p].link = Space.Nodes[q].link;
 Space.Nodes[q].link = Space.newptr;   //释放，链入备用链表表头
 Space.newptr = q;
 return 1;
}
```

### 循环链表

- 特点:最后一个结点的 link 指针不为NULL，而是指向第一个结点。只要已知表中某一结点的地址，就可搜寻所有结点的地址。
- 存储结构:链式存储结构
-  单循环链表：在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。    
- 为了使空表和非空表的处理一致，循环链表中也可设置一个头结点。这样，空循环链表仅有一个自成循环的头结点表示。

### 第二章作业三

- 1、 设计一个算法，将链表中所有结点的链接方向“原地”逆转，即要求仅利用原表的存储空间（也就是说，算法的空间复杂都为O(1)）。

  所有源码：

  ```c
  typedef int listData;
  
  typedef struct node {
  
    listData data;
  
    struct node *next;
  
  }ListNode;
  
   
  
  typedef ListNode *LinkList;
  
   
  
  void InitList(LinkList &first){
  
    first =NULL;
  
  }
  
   
  
  int ListInsert(LinkList &first,listData x,int i){
  
    LinkList p,newnode;
  
    newnode=(ListNode* )malloc(sizeof(ListNode));
  
    newnode->data=x;
  
    p= first;
  
    if(i==1){
  
  ​    newnode->next=p;
  
  ​    first=newnode;
  
    }
  
    if(!p||i<1){
  
  ​    
  
  ​    return NULL;
  
    }
  
    int k;
  
    k=1;
  
    while(p&&k<i-1){
  
  ​    p=p->next;
  
  ​    k++;
  
    }
  
    if(p){
  
    newnode->next=p->next;
  
    p->next=newnode;
  
    }
  
    else{
  
  ​    free(newnode);
  
  ​    return NULL;
  
    }
  
    return 1;
  
  }
  
  int Reverse(LinkList &first){
  
    LinkList p,q,x;
  
    p=first;
  
    q=first;
  
    x=first;
  
    int i;
  
    i=0;
  
    while(q){
  
  ​    q=q->next;
  
  ​    i++;  //计算链表长度
  
    }
  
    q=first;
  
    for(int j=i;j>0;j--){
  
  ​    while(x->next){
  
  ​      x=x->next; //指向当前原顺序链表最后一个节点
  
  ​    }
  
  ​    if(j==i){
  
  ​      q=x;  //用q指针记住原链表最后一个节点（翻转后的第一个节点）
  
  ​    }
  
  ​    if(j==1){
  
  ​      p=first; //原链表表按原顺序只剩两个节点时候p指向第一个节点
  
  ​    }
  
  ​    else{
  
  ​      while(p->next->next){
  
  ​        p=p->next; //指向x指向节点的前一个节点
  
  ​      }
  
  ​    }
  
    x->next=p; //翻转过程 后一个节点的next指向前一个节点
  
    p->next=NULL; //把前一个节点的next先断掉 原链表长度-1
  
    x=first; //x，q回到初始节点重新遍历
  
    p=first;
  
    }
  
    first=q;
  
    return 1;
  
  }
  
  int ShowList(LinkList first){
  
    LinkList p=first;
  
    int i;
  
    i=1;
  
    while(p){
  
  ​    printf("a[%d]=%d\n",i,p->data);
  
  ​    p=p->next;
  
  ​    i++;
  
    }
  
    return 1;
  
  }
  
  int main(int argc, const char * argv[]) {
  
    LinkList L;
  
    InitList(L);
  
    for(int i=1;i<=5;i++){
  
  ​    ListInsert(L, i*10, i);
  
    }
  
    ShowList(L);
  
    Reverse(L);
  
    printf("翻转后\n");
  
    ShowList(L);
  
    return 0;
  
  }
  
   
  ```

  实现结果 完成翻转

  ​                               

  2、定义静态链表的存储结构；写出不带头结点静态链表的插入和删除算法。

  ```c
  typedef int ElemType;
  
  typedef struct
  
  {
  
    ElemType data;
  
    int cur;
  
  } StaticLinkList[MAXSIZE];
  
  //在备用表中找到并返回第一个元素的下标，并改变数组[0]的cur
  
  int Malloc_SL(StaticLinkList space)
  
  {
  
    int i = space[0].cur;
  
    if (space[0]. cur)
  
  ​    space[0]. cur = space[i].cur;
  
    return i;
  
  }
  
  //获取使用链表的长度
  
  int ListLength(StaticLinkList L)
  
  {
  
    int j=0;
  
    int i=L[MAXSIZE-1].cur;
  
    while(i)
  
    {
  
  ​    i=L[i].cur;
  
  ​    j++;
  
    }
  
    return j;
  
  }
  
  //插入操作
  
  ElemType ListInsert(StaticLinkList L, int i, ElemType x)
  
  {
  
    int j, k, l;
  
    k = MAXSIZE - 1;
  
    //判断是否超范围
  
    if (i < 1 || i > ListLength(L) + 1)
  
  ​    return 0;
  
    //返回备用表第一个元素的下标
  
    j = Malloc_SL(L);
  
   
  
    if (j)
  
    {
  
  ​    L[j].data = x;
  
  ​    //找到i前面的元素下标k
  
  ​    for(l = 1; l <= i - 1; l++)
  
  ​      k = L[k].cur;
  
  ​    //j继承k的cur
  
  ​    L[j].cur = L[k].cur;
  
  ​    L[k].cur = j;
  
  ​    return 1;
  
    }
  
    return 0;
  
  }
  
  void Free_SL(StaticLinkList space, int i)
  
  {
  
    space[i].cur = space[0].cur;
  
    space[0].cur = i;
  
  }
  
  //删除操作
  
  ElemType ListDelete(StaticLinkList L, int i)
  
  {
  
    int j, k;
  
    if (i < 1 || i > ListLength(L))
  
  ​    return 0;
  
    k = MAXSIZE - 1;
  
    for (j = 1; j <= i - 1; j++)
  
  ​    k = L[k].cur;
  
    j = L[k].cur;
  
    L[k].cur = L[j].cur;
  
    Free_SL(L, j);
  
     return 1;
  
  }
  ```

  3、已知一个带有表头结点的单链表，结点结构为(data，ink)，假设该链表只给出了头指针first。在不改变链表的前提下，请设计一个尽可能高效的算法，査找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结点的data域的值，并返回1。（1）描述算法基本设计思想；（2）描述算法实现步骤；（3）采用程序设计语言描述算法。

  ```c
  int SearchK(LinkList &list,int k){
  
    //查找链表list倒数第k个结点，并输出该结点data域的值
  
    LinkList p,q;
  
    p=list->next;
  
    q=list->next;
  
    int count=0;//计数器初始化为0
  
    while(p){//指针p依次遍历链表直至最后一个结点
  
  ​    if(count<k){
  
  ​      count++;
  
  ​    }
  
  ​    else{
  
  ​      q=q->next;}
  
  ​      p=p->next;
  
  ​    }
  
    if(count<k){
  
  ​    return 0;}
  
    else{
  
  ​    return q->data;
  
  ​    }
  
  }
  ```

### 双向链表

- ​     和单链表类似，双链表一般也是由头指针唯一确定的，增加头指针也能使双链表上的某些运算变得方便，将头结点和尾结点链接起来也能构成循环链表，并称之为双向链表。
- 设指针p指向某一结点，则双向链表结构的对称性可用下式描述：
- (p—>prior)—>next=p=(p—>next)—>prior
-  即结点*p的存储位置既存放在其前趋结点*(p—>prior)的直接后继指针域中，也存放 在它的后继结点*(p—>next)的直接前趋指针域中。
- 双向链表优点：访问、插入、删除更方便、速度更快。
- 不足：以空间换时间

### 双向循环链表

```c
typedef int ListData;

typedef struct dnode {

  ListData data;             

  struct dnode * prior, * next;   

} DblNode;

typedef DblNode * DblList;     
```

初始化双向循环链表

```c
void InitList( DblList  &first ) {
                  //初始化带头结点的双向循环链表first
  first = ( DblNode*) malloc ( sizeof ( DblNode ) );
  if ( !first )
    { print ( “存储分配错!\n” ); exit (1); }
  first→prior = first→next = first;
                       //表头结点的链指针指向自己
}
```

求双向循环链表长度

```c
int ListLength ( DblList first ) {
             //计算带头结点的双向循环链表的长度
  DblNode * p = first→next;
  int count = 0;
  while ( p != first ) 
     { p = p→next; count++; }
  return count;
} 
```

```c
int ListInsert ( DblList first, int i, ListData x ) {
   //在带头结点的双向循环链表first的第i个结点前插入x
   DblNode * p = LocateElem ( first, i-1 );  
                         //指针定位于插入位置
   if ( p == first && i != 1) return 0;
   DblNode * q = ( DblNode * ) malloc
      ( sizeof ( DblNode ) );          //分配结点
   q→data = x;
   q→prior = p;  q→next = p→next;
   p→next = q; q→next→prior = q; 
                                 //链入新结点
   return 1;
}
```

```c
int ListDelete( DblList first, int i ) {
           //在带头结点的双向循环链表first的删除第i个结点
   DblNode * p = LocateElme( first, i );  
                         //指针定位于删除结点位置
   if ( p == first ) return 0;
   p→next→prior = p→prior;
   p→prior→next = p→next;       //删除结点 p
   free ( p );                      //释放
   return 1;
}
```

### 第二章作业四

1、 分别在带头结点的双链表中的第一个值为x的结点之前、之后插入元素值为y的结点，分别编写各自的算法。

之前插入

```c
int y_insert(Dlinklist **head, int x, int y)  

{

  linklist L = (*head) -> next, p;

  while(L && L -> data != x) 

​    L = L -> next;

  if(!L)     

​    return NULL;

  else

  {

​    p = (linklist)malloc(sizeof(Dlinklist));     

​    p -> data = y;       

​    L -> prior -> next = p;   

​    p -> prior = L -> prior;

​    L -> prior = p;

​    p -> next = L;

​    return 1;

  }

}
```

之后插入

```c
int y_afterinsert(Dlinklist **head, int x, int y) 

{

  linklist L = (*head) -> next, p;

  while(L && L -> data != x) 

​    L = L -> next;

  if(!L)     

​    return NULL;

  else

  {

​    p->next = L->next;

​    p->prior = L;

​    L->next->prior = p;

​    L->next = p;

​    return 1;

  }

}

 


```

2、有一个双链表L，其中有n(n>=1)个值不相同的数据节点，设计一个算法删除最大值的结点。 

```c
 void DeleteNode(DLinkList &dlLink, int x)

{

  DLinkList p = dlLink;

  DLinkList deleteNode;

  int max = 0;

  while (p)

  {

​    max = p->data;

​    p = p->next;

​    if (p->data > max)

​    {

​      max = p->data;

​    }

  }

  p = dlLink;

  while (p)

  {

​    if (p->data == max)

​    {

​      break;

​    }

​    p = p->next;

  }

  deleteNode = p->next;

  deleteNode->next->prev = p;

  p->next = deleteNode->next;

  free(deleteNode);

}
```

## 第三章 栈与递归

- ## 递归的定义

- ##  若一个对象部分地包含它自己, 或用它自己给自己定义, 则称这个对象是递归的；若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。 

- n**以下三种情况常常用到递归方法**

  Ø**递归定义的数学函数**

  Ø**具有递归特性的数据结构**

  Ø**可递归求解的问题**

- 分治法

  - 对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解

  - **必备的三个条件**

    - 1、能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的

      2、可以通过上述转化而使问题简化

      3、必须有一个明确的递归出口，或称递归的边界

- 递归的优缺点

  - 优点：结构清晰，程序易读
  - 缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。

1. 栈

- §定义:是限定仅在表尾进行插入或删除操作的线性表。
- §允许插入和删除的一端
-  称为栈顶(top)，另一端
-  称为栈底(bottom)
- §特点:后进先出(先进后出)

### 顺序栈

§顺序栈：栈的顺序存储结构，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，

 指针top指向栈顶元素在顺序栈中的下一个位置，

 指针base为栈底指针，指向栈底的位置。

```c
#define STACK_INIT_SIZE 100；//存储空间初始分配量
#define STACKINCREMENT 10；//存储空间分配的增量
typedef char SElemType;
typedef struct { //顺序栈定义
 SElemType *base; //栈底指针 
 SElemType *top;  //栈顶指针 
 int stacksize； //当前已分配的存储空间
} SqStack；
```

•初始化

```c
Status InitStack ( SqStack &S) {  //建空栈

 S.base =( SElemType *) malloc(STACK_INIT_SIZE *  sizeof(SElemType));

 if (!S.base) exit(OVERFLOW);  //存储分配失败

 S.top = S.base ; 

 S.Stacksize = STACK_INIT_SIZE ;

 return OK;

} 
```

§判栈空

```c
Status StackEmpty (SqStack &S) {

  if( S.top == S.base ) return TRUE; //栈空

  else return FALSE; 

}


```

§判栈满

```c
Status StackFull (SqStack &S) {

 if( S.top - S.base >= S.StackSize )    //栈满

  return TRUE; 

 else return FALSE;

}
```

求栈的长度

```c
int StackLength( SqStack S )

{

 return S.top – S.base;

}
```

清空顺序栈

```c
Status ClearStack( SqStack S )

{

 if( S.base ) S.top = S.base;

 return OK;

}
```

销毁顺序栈

```c
Status DestroyStack( SqStack &S )

{

 if( S.base )

 {

 delete S.base ;

 S.stacksize = 0;

 S.base = S.top = NULL;

 }

 return OK;

}
```

§入栈(进栈)

```c
Status Push (SqStack &S, SElemType e) {

//插入元素e为新的栈顶元素

  if ( StackFull (S) ){ //栈满，追加存储空间

 S.base = ( SElemType *)malloc(S.base ,

   (S.stacksize + STACKINCREMENT) *    sizeof(SElemType));

 if(! S.base) exit(OVERFLOW);

  S.top = S.base + S.stacksize;

 S.stacksize += STACKINCREMENT; 

 }
 *(S.top++) = e;
 return OK;
}
```

顺序栈出栈

```c
Status Pop( SqStack &S, SElemType &e)  
{//若栈空返回ERROR, 否则删除栈顶元素，用e返回其值.
	if( S.top == S.base ) // 栈空
        return ERROR; 	
	e＝ *--S.top;
	return OK;
}
```

取顺序栈栈顶元素

```c
Status GetTop( SqStack S, SElemType &e)  
{//若栈空返回ERROR, 否则栈顶元素读到e并返回OK
	if( S.top == S.base )	 return ERROR; 	// 栈空
	e = *( S.top – 1 );
	return OK;
}
```

### 静态顺序栈

### 链栈

```c
typedef int SElemType;
typedef struct node {
    SElemType data;	       //结点	
    struct node *next;	       //链指针
} StackNode;
typedef struct {
    StackNode *top;           //栈顶指针
} LinkStack;

```



1. 队列

   1. 基本概念
   2. 定义:只允许在表的一端进行插入，而在另一端删除元素的线性表。也是一种运算受限的线性表。
   3.   在队列中，允许插入的一端叫队尾(rear)，
   4. 允许删除的一端称为队头(front)。
   5. 先进先出

2. 队列、栈和线性表的区别与联系

   1. 栈和队列都是线性表，都是限制了插入删除点的线性表（或者说是控制了访问点的线性表）

      区别：栈只允许在一端进行插入或删除操作的线性表，其最大的特点是“后进后出”；队列是只允许在一端进行插入，另一端进行删除操作的线性表，其最大的特点是“先进后出”；一般的线性表允许在表中任意位置进行插入或删除操作。

      联系（共同点）：n个（同类）数据元素的有限序列称为线性表。线性表的特点是数据元素之间存在“一对一”的关系，栈和队列都是操作受限制的线性表，他们和线性表一样，数据元素之间都存在“一对一”的关系。栈和队列都是只能在线性表的端点插入和删除。

### 循环队列

```c
#define MAXSIZE 100   //最大长度

Typedef struct{

 QElemType *data; //初始化的动态分配存储空间

 int front; //头指针 

 int rear; //尾指针

} SqQueue
```

§初始化队列

```c
void InitQueue ( SqQueue &Q ) {

//构造空队列

 Q.data=(QueueData *)malloc(MAXSIZE  *sizeof(QueueData));

 If(! Q.data)  exit(OVERFLOW);

 Q.rear = Q.front = 0;

 return ok

}
```

求循环队列的长度

```c
int QueueLength (SqQueue Q){

  return (Q.rear-Q.front+Maxsize)%Maxsize;               

 }
```

1） Q.rear>=Q.front, 那么Q.rear-Q.front。

2） Q.rear < Q.front, 那么Q.rear-Q.front+Maxsize

统一为： (Q.rear-Q.front+Maxsize)%Maxsize。

ü当Q.rear-Q.front为正数时，加上Maxsize就超过了最大空间数，取余后就正好是元素个数；

ü当Q.rear-Q.front为负数时，加上Maxsize就正好是元素个数，由于小于Maxsize，故取余运算对其没有影响。

所以， %Maxsize是为了防止Q.rear-Q.front为正数的情况，+Maxsize为了防止Q.rear-Q.front为负数的情况。

§判队空

```c
int QueueEmpty ( SqQueue &Q ) {

  return Q.rear == Q.front;

}
```

§判队满

```c
int QueueFull ( SqQueue &Q ) {

  return (Q.rear+1) % QueueSize == Q.front;

}
```

§入队

```c
int EnQueue ( SqQueue &Q, QElemType e ) {
  if ( QueueFull (Q) ) return 0;
  Q.data[Q.rear] = e;
  Q.rear = ( Q.rear+1) % MAXSIZE;
return 1;

}
```

§出队

```c
int DeQueue ( SqQueue &Q, QElemType &e ) {

  if ( QueueEmpty (Q) ) return 0; 

  e = Q.data[Q.front]; 

 Q.front = ( Q.front+1) % MAXSIZE;

 return 1;

}
```

§取队头

```c
int GetFront ( SqQueue &Q, QElemtype &e ) {

   if ( QueueEmpty (Q) ) return 0;

   e = Q.data[(Q.front+1) % MAXSIZE];

   return 1;

}
```

### 链队列

链式队列的定义

```c
typedef struct QNode { 

  QElemType   data;  //队列结点数据

  struct QNode *next; //结点链指针

} QNode, *QueuePtr;   //链队数据结点类型

typedef struct {

  QueuePtr  front;   //队头指针

  QueuePtr  rear;   //队尾指针

} LinkQueue;  //链队结点类型
```

§初始化

```c
 Status InitQueue (LinkQueue &Q){

  Q.front=Q.rear=(QueuePtr) malloc(sizeof(QNode)); 

  if(!Q.front) exit(OVERFLOW);

  Q.front->next=NULL;

   return OK;

}


```

销毁链队列

```c
Status DestroyQueue (LinkQueue &Q){

  while(Q.front){

   Q.rear=Q.front->next;

   free(Q.front);

   Q.front=Q.rear;  }  

  return OK;

}
```

§判断队空

```c
int QueueEmpty ( LinkQueue &Q ) {

  return Q.front == NULL;

}
```

//当Q.front==NULL且Q.rear=NULL时，链式队列为空

§取队头元素

```c
int GetFront ( LinkQueue &Q, QueueData &e ) {

  if ( QueueEmpty (Q) ) return 0; 

  e = Q.front->data; return 1; 

}
```

§入队

```c
//插入元素e为Q的新的队尾结点

Status EnQueue(QueuePtr Q, QElemType e) {

  QueuePtr q = (QueuePtr)malloc(sizeof(QNode));

  if (!q) {        //存储分配失败

    exit(OVERFLOW);

  }

  q->data = e;

  q->next = NULL; 

  Q->rear->next = q; //先使rear指向结点的next指向新节点q

  Q->rear = q;     //再使尾指针指向q

  return OK;

}
```

§出队

```c
int DeQueue ( LinkQueue &Q, QueueData &e) {

//删去队头结点，并返回队头元素的值

  if ( QueueEmpty (Q) ) return 0; //判队空

  QueueNode *p = Q.front; 

  e = p->data; //保存队头的值

  Q.front= Q.front->next;  //新队头

   if (Q.rear == p)   Q.rear = Q.front;  //对队尾指针重新赋值（指向头 结点）

 free (p);

  return 1; 

}
```

循环队列与链队列的比较

从时间上考虑，循环队列和链队列的基本操作都是O(1),不过循环队列是事先已申请好空间，使用期间不会释放。而对于链队列，每次申请和释放结点也会存在一些时间开销。如果入队和出队频繁，两者还是有细微差异的。
 　从空间来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但是是可以接受的。所以从空间上说，链队列更加灵活。
 　总的来说，在可以确定链队列最大长度的情况下，建议使用循环队列。如果无法预估队列的长度，则使用链队列。

Ø循环队列要事先申请好空间，整个过程都不能释放，而且要有固定的长度，如果长度事先无法估计，这种方式显然不够灵活；

Ø所以就引入了链式存储队列，其实就是线性表的单链表，只是它只能对尾进，队头出。并且规定队头指针指向链队列的头结点，对尾指针指向终端节点，当队列为空时，front和rear都指向头结点。入队操作，就是在链表尾部插入结点；出队操作就是头结点的后继结点出队，然后将头结点的后继后移。如果最后除了头结点外，只剩一个元素了，就把rear也指向头结点。